<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Weather Conditions Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      margin-bottom: 30px;
      color: #333;
    }
    .loading {
      text-align: center;
      padding: 50px;
      font-size: 18px;
      color: #666;
    }
    .charts-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      max-width: 1400px;
    }
    @media (min-width: 768px) {
      .charts-container {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    .chart-wrapper {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .chart-wrapper h2 {
      margin-bottom: 15px;
      color: #444;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .chart-wrapper h2 .date-range {
      font-size: 14px;
      color: #666;
      font-weight: normal;
      display: none;
    }
    .chart-wrapper h2 a {
      font-size: 14px;
      color: #2196F3;
      text-decoration: none;
    }
    .chart-wrapper h2 a:hover {
      text-decoration: underline;
    }
    .image-icon {
      cursor: pointer;
      font-size: 18px;
      text-decoration: none;
      transition: transform 0.2s;
    }
    .image-icon:hover {
      transform: scale(1.2);
    }
    .image-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      animation: fadeIn 0.2s;
    }
    .image-overlay.active {
      display: flex;
    }
    .image-overlay img {
      max-width: 90%;
      max-height: 90%;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .image-overlay-close {
      position: absolute;
      top: 20px;
      right: 30px;
      color: white;
      font-size: 40px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
    }
    .image-overlay-close:hover {
      color: #ccc;
    }
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    .chart-wrapper canvas {
      max-height: 300px;
      width: 100% !important;
      height: auto !important;
    }
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      .chart-wrapper {
        padding: 15px;
      }
      .chart-wrapper h2 {
        font-size: 16px;
        flex-wrap: wrap;
      }
      .chart-wrapper h2 .date-range {
        display: inline;
      }
      .chart-wrapper h2 .map-link-text {
        display: none;
      }
      .chart-wrapper canvas {
        max-height: 250px;
      }
    }
    .error {
      color: #d32f2f;
      padding: 20px;
      background: #ffebee;
      border-radius: 4px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1>Weather Conditions Dashboard</h1>
  <div id="loading" class="loading">Loading data...</div>
  <div id="error" class="error" style="display:none;"></div>
  <div id="charts" class="charts-container"></div>

  <!-- Image Overlay -->
  <div id="imageOverlay" class="image-overlay" onclick="hideImageOverlay()">
    <span class="image-overlay-close">&times;</span>
    <img id="overlayImage" src="" alt="" onclick="event.stopPropagation()">
  </div>

  <script>
    // REPLACE THIS WITH YOUR GOOGLE SHEET ID
    const SHEET_ID = '1wPqlgJc83YASKPFbduuAnIooPvPXBMiVUhn4jSPDXxY';
    const SHEET_NAME = 'Sheet1';
    const DAYS_TO_SHOW = 60; // Last 60 days

    // Locations configuration
    const LOCATIONS_CONFIG = [
      { name: "T√∂ftfossen", latitude: 62.4276937, longitude: 9.5877706, area: "Oppdal" },
      { name: "Vinstra", latitude: 62.5131938, longitude: 9.6361003, area: "Oppdal" },
      { name: "Jukulkula", latitude: 61.8068182, longitude: 9.3382779, area: "Oppdal" },
      { name: "Thorfossen", latitude: 61.0284129, longitude: 7.6697203, area: "Laerdal" },
      { name: "Hydnefossen", latitude: 60.8120288, longitude: 8.6221037, area: "Hemsedal" },
      { name: "Gr√∂tnuten", latitude: 60.8602061, longitude: 8.6125362, area: "Hemsedal" },
      { name: "T√•gbekken, Litchdalen", latitude: 62.589781, longitude: 8.5289662, area: "Sunndalen" },
      { name: "Mardalsfossen, nedre", latitude: 62.4719323, longitude: 8.1202897, area: "Eikesdal" },
      { name: "Brudsl√∂ret, eikesdal", latitude: 62.4097087, longitude: 8.3688476, area: "Eikesdal" },
      { name: "Vettisfossen", latitude: 61.380309, longitude: 7.9454885, area: "Laerdal" },
      { name: "Code red", latitude: 59.063172, longitude: 7.5502945, area: "Setesdal" },
      { name: "Vinnu, Sunndalen", latitude: 62.6628477, longitude: 8.670175, area: "Sunndalen" },
      { name: "Lipton", latitude: 59.877704, longitude: 8.5546708, area: "Rjukan" },
      { name: "Lang√•ni", latitude: 61.1771175, longitude: 8.4204999, area: "Valdres" },
      { name: "Stavadalen", latitude: 60.832396, longitude: 9.3787648, area: "Valdres" },
      { name: "Bakkenkollen, Bagn", latitude: 60.5529, longitude: 9.8254, area: "Valdres" },
      { name: "Grindane, Vagn", latitude: 61.1053, longitude: 8.5296, area: "Valdres" },
      { name: "Skiri, Romsdalen", latitude: 62.4326715, longitude: 7.9373157, area: "Romsdalen" },
      { name: "Reppanuten", latitude: 60.806669, longitude: 7.3520529, area: "Aurland" },
      { name: "Kjerrskredkvelven", latitude: 60.8648163, longitude: 6.8294383, area: "Aurland" }
    ];

    // Locations with images available
    const LOCATIONS_WITH_IMAGES = [
      "Brudsl√∂ret, eikesdal",
      "Code red",
      "Hydnefossen",
      "Jukulkula",
      "Lang√•ni",
      "Mardalsfossen, nedre",
      "Stavadalen",
      "T√•gbekken, Litchdalen",
      "Thorfossen",
      "T√∂ftfossen",
      "Vinnu, Sunndalen",
      "Vinstra"
    ];

    // Location coordinates for map links
    const LOCATION_COORDS = {
      "T√∂ftfossen": { lat: 62.4276937, lon: 9.5877706 },
      "Vinstra": { lat: 62.5131938, lon: 9.6361003 },
      "Jukulkula": { lat: 61.8068182, lon: 9.3382779 },
      "Thorfossen": { lat: 61.0284129, lon: 7.6697203 },
      "Hydnefossen": { lat: 60.8120288, lon: 8.6221037 },
      "T√•gbekken, Litchdalen": { lat: 62.589781, lon: 8.5289662 },
      "Mardalsfossen, nedre": { lat: 62.4719323, lon: 8.1202897 },
      "Brudsl√∂ret, eikesdal": { lat: 62.4097087, lon: 8.3688476 },
      "Vettisfossen": { lat: 61.380309, lon: 7.9454885 },
      "Code red": { lat: 59.063172, lon: 7.5502945 },
      "Vinnu, Sunndalen": { lat: 62.6628477, lon: 8.670175 },
      "Lipton": { lat: 59.877704, lon: 8.5546708 },
      "Lang√•ni": { lat: 61.1771175, lon: 8.4204999 },
      "Stavadalen": { lat: 60.832396, lon: 9.3787648 },
      "Bakkenkollen, Bagn": { lat: 60.5529, lon: 9.8254 },
      "Grindane, Vagn": { lat: 61.1053, lon: 8.5296 },
      "Skiri, Romsdalen": { lat: 62.4326715, lon: 7.9373157 }
    };

    async function loadData() {
      try {
        // Use CSV export format - more reliable for public sheets
        const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=0`;
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const csvText = await response.text();
        return parseCSV(csvText);
      } catch (error) {
        console.error('Error loading data:', error);
        throw error;
      }
    }

    function parseCSV(csv) {
      const lines = csv.trim().split('\n');

      // Proper CSV parsing that handles quoted fields with commas
      function parseLine(line) {
        const values = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
          const char = line[i];

          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            values.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        values.push(current);

        return values;
      }

      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = parseLine(lines[i]);
        if (values.length >= 4) {
          data.push({
            date: values[0],
            hour: values[1],
            location: values[2],
            temperature: parseFloat(values[3]),
            precipitation: values[4] ? parseFloat(values[4]) : 0,
            cloudCover: values[5] ? parseFloat(values[5]) : null
          });
        }
      }

      return data;
    }

    function filterRecentData(data, days) {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);
      const cutoffStr = cutoffDate.toISOString().split('T')[0];

      return data.filter(row => row.date >= cutoffStr);
    }

    function groupByLocation(data) {
      const groups = {};

      data.forEach(row => {
        if (!groups[row.location]) {
          groups[row.location] = [];
        }
        groups[row.location].push(row);
      });

      // Sort each location's data by date and hour
      Object.keys(groups).forEach(location => {
        groups[location].sort((a, b) => {
          const dateCompare = a.date.localeCompare(b.date);
          return dateCompare !== 0 ? dateCompare : a.hour.localeCompare(b.hour);
        });
      });

      return groups;
    }

    function groupLocationsByArea() {
      const areaGroups = {};

      LOCATIONS_CONFIG.forEach(loc => {
        const area = loc.area || 'Other';
        if (!areaGroups[area]) {
          areaGroups[area] = [];
        }
        areaGroups[area].push(loc.name);
      });

      return areaGroups;
    }

    function createChart(location, data) {
      const wrapper = document.createElement('div');
      wrapper.className = 'chart-wrapper';

      // Get date range from data
      const firstDate = data[0].date;
      const lastDate = data[data.length - 1].date;
      const formatDate = (dateStr) => {
        const date = new Date(dateStr + 'T00:00:00');
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
      };
      const dateRange = `(${formatDate(firstDate)} - ${formatDate(lastDate)})`;

      const title = document.createElement('h2');

      // Add image icon first if image exists for this location
      if (LOCATIONS_WITH_IMAGES.includes(location)) {
        const imagePath = `img/${location}.jpeg`;
        const imageIcon = document.createElement('span');
        imageIcon.className = 'image-icon';
        imageIcon.textContent = 'üì∑';
        imageIcon.title = 'View photo';
        imageIcon.onmouseenter = () => showImageOverlay(imagePath, location);
        imageIcon.onclick = () => showImageOverlay(imagePath, location); // For mobile
        title.appendChild(imageIcon);
      }

      const locationName = document.createTextNode(location + ' ');
      title.appendChild(locationName);

      // Add date range span with class for mobile visibility
      const dateSpan = document.createElement('span');
      dateSpan.className = 'date-range';
      dateSpan.textContent = dateRange;
      title.appendChild(dateSpan);

      // Add map link and yr.no forecast link if coordinates are available
      const locationConfig = LOCATIONS_CONFIG.find(loc => loc.name === location);
      if (locationConfig) {
        const mapLink = document.createElement('a');
        // Use search format with lat,lon - norgeskart will search for it
        mapLink.href = `https://norgeskart.no/#!?project=norgeskart&zoom=15&sok=${encodeURIComponent(locationConfig.latitude + ',' + locationConfig.longitude)}`;
        mapLink.target = '_blank';
        mapLink.innerHTML = 'üìç <span class="map-link-text">View on map</span>';
        title.appendChild(mapLink);

        // Add yr.no forecast link
        const yrLink = document.createElement('a');
        const lat = locationConfig.latitude.toFixed(3);
        const lon = locationConfig.longitude.toFixed(3);
        yrLink.href = `https://www.yr.no/nb/detaljer/tabell/${lat},%20${lon}`;
        yrLink.target = '_blank';
        yrLink.innerHTML = 'üå§Ô∏è <span class="map-link-text">Yr forecast</span>';
        yrLink.style.marginLeft = '8px';
        title.appendChild(yrLink);
      }

      wrapper.appendChild(title);

      const canvas = document.createElement('canvas');
      wrapper.appendChild(canvas);

      const labels = data.map(d => `${d.date} ${d.hour}:00`);

      // Clamp temperatures to -20 to 10 range for display
      const temperatures = data.map(d => {
        const temp = d.temperature;
        if (temp < -20) return -20;
        if (temp > 10) return 10;
        return temp;
      });

      // Color code each point based on ACTUAL temperature (before clamping)
      // < -10: really good (dark green)
      // -10 to 0: good (light green)
      // 0 to 5: bad (orange)
      // > 5: really bad (red)
      const pointColors = data.map(d => {
        const temp = d.temperature;
        if (temp < -10) return '#1B5E20'; // dark green
        if (temp < 0) return '#4CAF50';   // light green
        if (temp < 5) return '#FF9800';   // orange
        return '#D32F2F';                 // red
      });

      // Separate clear sky (star) data from cloudy (circle) data
      const clearSkyIndices = [];
      const cloudyIndices = [];

      data.forEach((d, i) => {
        if (d.cloudCover !== null && d.cloudCover < 25) {
          clearSkyIndices.push(i);
        } else {
          cloudyIndices.push(i);
        }
      });

      // Prepare precipitation data for bars (scaled to fit 0-10 range)
      const precipitations = data.map(d => d.precipitation || 0);

      new Chart(canvas, {
        type: 'scatter',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Precipitation (mm)',
              type: 'bar',
              data: precipitations.map((precip, i) => ({ x: i, y: precip })),
              backgroundColor: 'rgba(100, 181, 246, 0.5)',
              borderColor: 'rgba(66, 165, 245, 0.8)',
              borderWidth: 1,
              yAxisID: 'y-temp',
              base: 0,
              barThickness: 2,
              maxBarThickness: 2,
              order: 3
            },
            // Yellow circles behind stars
            {
              label: 'Clear Sky Background',
              data: clearSkyIndices.map(i => ({ x: i, y: temperatures[i] })),
              backgroundColor: '#FFD700',
              borderColor: '#000000',
              borderWidth: 1,
              pointStyle: 'circle',
              pointRadius: 5,
              pointHoverRadius: 5,
              yAxisID: 'y-temp',
              order: 2,
              tooltip: {
                enabled: false
              }
            },
            // Stars on top of yellow circles (clear skies)
            {
              label: 'Temperature (Clear Sky)',
              data: clearSkyIndices.map(i => ({ x: i, y: temperatures[i] })),
              backgroundColor: clearSkyIndices.map(i => pointColors[i]),
              borderColor: clearSkyIndices.map(i => pointColors[i]),
              pointStyle: 'star',
              pointRadius: 5,
              pointHoverRadius: 7,
              yAxisID: 'y-temp',
              order: 1
            },
            // Regular circles (cloudy)
            {
              label: 'Temperature (Cloudy)',
              data: cloudyIndices.map(i => ({ x: i, y: temperatures[i] })),
              backgroundColor: cloudyIndices.map(i => pointColors[i]),
              borderColor: cloudyIndices.map(i => pointColors[i]),
              pointStyle: 'circle',
              pointRadius: 3,
              pointHoverRadius: 5,
              yAxisID: 'y-temp',
              order: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              mode: 'nearest',
              intersect: true,
              callbacks: {
                title: function(tooltipItems) {
                  if (!tooltipItems || !tooltipItems.length) return '';
                  const idx = Math.round(tooltipItems[0].parsed.x);
                  return labels[idx] || '';
                },
                label: function(context) {
                  if (!context || !context.parsed) return '';

                  const dataIndex = Math.round(context.parsed.x);
                  const datasetIndex = context.datasetIndex;

                  if (dataIndex < 0 || dataIndex >= data.length) return '';

                  const precip = data[dataIndex].precipitation || 0;

                  // Precipitation dataset
                  if (datasetIndex === 0) {
                    return `Precipitation: ${precip.toFixed(1)}mm (next 6h)`;
                  }

                  // Skip yellow background layer (dataset 1)
                  if (datasetIndex === 1) {
                    return null;
                  }

                  // Temperature dataset
                  const actualTemp = data[dataIndex].temperature || 0;
                  const displayTemp = context.parsed.y.toFixed(1);
                  let status = '';
                  if (actualTemp < -10) status = ' (Really Good!)';
                  else if (actualTemp < 0) status = ' (Good)';
                  else if (actualTemp < 5) status = ' (Bad)';
                  else status = ' (Really Bad!)';

                  // Show if clamped
                  const clamped = Math.abs(actualTemp - context.parsed.y) > 0.1;
                  const tempDisplay = clamped ? `${actualTemp.toFixed(1)}¬∞C (capped at ${displayTemp}¬∞C)` : `${displayTemp}¬∞C`;

                  // Add cloud cover info
                  const cloudCover = data[dataIndex].cloudCover;
                  const cloudInfo = cloudCover !== null ? ` | Cloud cover: ${cloudCover.toFixed(0)}%${cloudCover < 25 ? ' ‚≠ê' : ''}` : '';

                  return `${tempDisplay}${status}${cloudInfo}`;
                }
              }
            },
            annotation: {
              annotations: {
                reallyGoodZone: {
                  type: 'box',
                  yMin: -20,
                  yMax: -10,
                  backgroundColor: 'rgba(27, 94, 32, 0.1)',
                  borderWidth: 0
                },
                goodZone: {
                  type: 'box',
                  yMin: -10,
                  yMax: 0,
                  backgroundColor: 'rgba(76, 175, 80, 0.1)',
                  borderWidth: 0
                },
                badZone: {
                  type: 'box',
                  yMin: 0,
                  yMax: 5,
                  backgroundColor: 'rgba(255, 152, 0, 0.1)',
                  borderWidth: 0
                },
                reallyBadZone: {
                  type: 'box',
                  yMin: 5,
                  yMax: 10,
                  backgroundColor: 'rgba(211, 47, 47, 0.1)',
                  borderWidth: 0
                },
                zeroLine: {
                  type: 'line',
                  yMin: 0,
                  yMax: 0,
                  borderColor: '#666',
                  borderWidth: 2,
                  borderDash: [5, 5]
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              type: 'linear',
              title: {
                display: window.innerWidth <= 768,
                text: 'Date'
              },
              ticks: {
                display: window.innerWidth > 768,
                callback: function(value) {
                  if (value >= 0 && value < labels.length) {
                    const label = labels[Math.floor(value)];
                    if (label) {
                      return label.split(' ')[0]; // Show date only
                    }
                  }
                  return '';
                },
                maxTicksLimit: 10,
                autoSkip: true
              }
            },
            'y-temp': {
              display: true,
              position: 'left',
              min: -20,
              max: 10,
              title: {
                display: window.innerWidth <= 768,
                text: 'Temperature (¬∞C)'
              },
              ticks: {
                display: window.innerWidth > 768,
                stepSize: 5
              }
            },
            'y-precip': {
              display: false
            }
          }
        }
      });

      return wrapper;
    }

    function showImageOverlay(imagePath, locationName) {
      const overlay = document.getElementById('imageOverlay');
      const overlayImg = document.getElementById('overlayImage');
      overlayImg.src = imagePath;
      overlayImg.alt = locationName;
      overlay.classList.add('active');
    }

    function hideImageOverlay() {
      const overlay = document.getElementById('imageOverlay');
      overlay.classList.remove('active');
    }

    async function init() {
      const loading = document.getElementById('loading');
      const error = document.getElementById('error');
      const chartsContainer = document.getElementById('charts');

      try {
        loading.style.display = 'block';
        error.style.display = 'none';

        const data = await loadData();
        const recentData = filterRecentData(data, DAYS_TO_SHOW);
        const locationGroups = groupByLocation(recentData);

        loading.style.display = 'none';

        if (Object.keys(locationGroups).length === 0) {
          error.textContent = 'No data found. Make sure your sheet is publicly accessible.';
          error.style.display = 'block';
          return;
        }

        // Group locations by area from config
        const areaGroups = groupLocationsByArea();

        // Sort areas alphabetically
        const areas = Object.keys(areaGroups).sort();

        // Change chartsContainer to block layout instead of grid
        chartsContainer.style.display = 'block';

        areas.forEach(area => {
          // Create area header
          const areaHeader = document.createElement('h2');
          areaHeader.textContent = area;
          areaHeader.style.marginTop = '40px';
          areaHeader.style.marginBottom = '20px';
          areaHeader.style.fontSize = '24px';
          areaHeader.style.color = '#333';
          chartsContainer.appendChild(areaHeader);

          // Create grid container for this area
          const areaGrid = document.createElement('div');
          areaGrid.className = 'charts-container';

          // Get locations for this area
          const locationNames = areaGroups[area].sort();

          locationNames.forEach(locationName => {
            // Check if we have data for this location
            if (locationGroups[locationName] && locationGroups[locationName].length > 0) {
              const chart = createChart(locationName, locationGroups[locationName]);
              areaGrid.appendChild(chart);
            }
          });

          chartsContainer.appendChild(areaGrid);
        });

      } catch (err) {
        loading.style.display = 'none';
        error.textContent = `Error loading data: ${err.message}. Make sure your Google Sheet is shared publicly and the SHEET_ID is correct.`;
        error.style.display = 'block';
      }
    }

    // ESC key to close overlay
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        hideImageOverlay();
      }
    });

    init();
  </script>
</body>
</html>
