<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Weather Conditions Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      padding: 20px;
      background: #f5f5f5;
    }
    h1 {
      margin-bottom: 30px;
      color: #333;
    }
    .loading {
      text-align: center;
      padding: 50px;
      font-size: 18px;
      color: #666;
    }
    .charts-container {
      display: grid;
      grid-template-columns: 1fr;
      gap: 20px;
      max-width: 1400px;
    }
    @media (min-width: 768px) {
      .charts-container {
        grid-template-columns: repeat(2, 1fr);
      }
    }
    .chart-wrapper {
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .chart-wrapper h2 {
      margin-bottom: 15px;
      color: #444;
      font-size: 18px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .chart-wrapper h2 a {
      font-size: 14px;
      color: #2196F3;
      text-decoration: none;
    }
    .chart-wrapper h2 a:hover {
      text-decoration: underline;
    }
    .chart-wrapper canvas {
      max-height: 300px;
      width: 100% !important;
      height: auto !important;
    }
    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      .chart-wrapper {
        padding: 15px;
      }
      .chart-wrapper h2 {
        font-size: 16px;
        flex-wrap: wrap;
      }
      .chart-wrapper canvas {
        max-height: 250px;
      }
    }
    .error {
      color: #d32f2f;
      padding: 20px;
      background: #ffebee;
      border-radius: 4px;
      margin: 20px 0;
    }
  </style>
</head>
<body>
  <h1>Weather Conditions Dashboard</h1>
  <div id="loading" class="loading">Loading data...</div>
  <div id="error" class="error" style="display:none;"></div>
  <div id="charts" class="charts-container"></div>

  <script>
    // REPLACE THIS WITH YOUR GOOGLE SHEET ID
    const SHEET_ID = '1wPqlgJc83YASKPFbduuAnIooPvPXBMiVUhn4jSPDXxY';
    const SHEET_NAME = 'Sheet1';
    const DAYS_TO_SHOW = 60; // Last 60 days

    // Location coordinates for map links
    const LOCATION_COORDS = {
      "TÃ¶ftfossen": { lat: 62.4276937, lon: 9.5877706 },
      "Vinstra": { lat: 62.5131938, lon: 9.6361003 },
      "Jukulkula": { lat: 61.8068182, lon: 9.3382779 },
      "Thorfossen": { lat: 61.0284129, lon: 7.6697203 },
      "Hydnefossen": { lat: 60.8120288, lon: 8.6221037 },
      "TÃ¥gbekken, Litchdalen": { lat: 62.589781, lon: 8.5289662 },
      "Mardalsfossen, nedre": { lat: 62.4719323, lon: 8.1202897 },
      "BrudslÃ¶ret, eikesdal": { lat: 62.4097087, lon: 8.3688476 },
      "Vettisfossen": { lat: 61.380309, lon: 7.9454885 },
      "Code red": { lat: 59.063172, lon: 7.5502945 },
      "Vinnu, Sunndalen": { lat: 62.6628477, lon: 8.670175 },
      "Lipton": { lat: 59.877704, lon: 8.5546708 },
      "LangÃ¥ni": { lat: 61.1771175, lon: 8.4204999 },
      "Stavadalen": { lat: 60.832396, lon: 9.3787648 },
      "Bakkenkollen, Bagn": { lat: 60.5529, lon: 9.8254 },
      "Grindane, Vagn": { lat: 61.1053, lon: 8.5296 },
      "Skiri, Romsdalen": { lat: 62.4326715, lon: 7.9373157 }
    };

    async function loadData() {
      try {
        // Use CSV export format - more reliable for public sheets
        const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=0`;
        const response = await fetch(url);

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const csvText = await response.text();
        return parseCSV(csvText);
      } catch (error) {
        console.error('Error loading data:', error);
        throw error;
      }
    }

    function parseCSV(csv) {
      const lines = csv.trim().split('\n');

      // Proper CSV parsing that handles quoted fields with commas
      function parseLine(line) {
        const values = [];
        let current = '';
        let inQuotes = false;

        for (let i = 0; i < line.length; i++) {
          const char = line[i];

          if (char === '"') {
            inQuotes = !inQuotes;
          } else if (char === ',' && !inQuotes) {
            values.push(current);
            current = '';
          } else {
            current += char;
          }
        }
        values.push(current);

        return values;
      }

      const data = [];
      for (let i = 1; i < lines.length; i++) {
        const values = parseLine(lines[i]);
        if (values.length >= 4) {
          data.push({
            date: values[0],
            hour: values[1],
            location: values[2],
            temperature: parseFloat(values[3]),
            precipitation: values[4] ? parseFloat(values[4]) : 0,
            cloudCover: values[5] ? parseFloat(values[5]) : null
          });
        }
      }

      return data;
    }

    function filterRecentData(data, days) {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);
      const cutoffStr = cutoffDate.toISOString().split('T')[0];

      return data.filter(row => row.date >= cutoffStr);
    }

    function groupByLocation(data) {
      const groups = {};

      data.forEach(row => {
        if (!groups[row.location]) {
          groups[row.location] = [];
        }
        groups[row.location].push(row);
      });

      // Sort each location's data by date and hour
      Object.keys(groups).forEach(location => {
        groups[location].sort((a, b) => {
          const dateCompare = a.date.localeCompare(b.date);
          return dateCompare !== 0 ? dateCompare : a.hour.localeCompare(b.hour);
        });
      });

      return groups;
    }

    function createChart(location, data) {
      const wrapper = document.createElement('div');
      wrapper.className = 'chart-wrapper';

      const title = document.createElement('h2');
      const locationName = document.createTextNode(location);
      title.appendChild(locationName);

      // Add map link if coordinates are available
      const coords = LOCATION_COORDS[location];
      if (coords) {
        const mapLink = document.createElement('a');
        // Use search format with lat,lon - norgeskart will search for it
        mapLink.href = `https://norgeskart.no/#!?project=norgeskart&zoom=15&sok=${encodeURIComponent(coords.lat + ',' + coords.lon)}`;
        mapLink.target = '_blank';
        mapLink.textContent = 'ðŸ“ View on map';
        title.appendChild(mapLink);
      }

      wrapper.appendChild(title);

      const canvas = document.createElement('canvas');
      wrapper.appendChild(canvas);

      const labels = data.map(d => `${d.date} ${d.hour}:00`);

      // Clamp temperatures to -20 to 10 range for display
      const temperatures = data.map(d => {
        const temp = d.temperature;
        if (temp < -20) return -20;
        if (temp > 10) return 10;
        return temp;
      });

      // Color code each point based on ACTUAL temperature (before clamping)
      // < -10: really good (dark green)
      // -10 to 0: good (light green)
      // 0 to 5: bad (orange)
      // > 5: really bad (red)
      const pointColors = data.map(d => {
        const temp = d.temperature;
        if (temp < -10) return '#1B5E20'; // dark green
        if (temp < 0) return '#4CAF50';   // light green
        if (temp < 5) return '#FF9800';   // orange
        return '#D32F2F';                 // red
      });

      // Separate clear sky (star) data from cloudy (circle) data
      const clearSkyIndices = [];
      const cloudyIndices = [];

      data.forEach((d, i) => {
        if (d.cloudCover !== null && d.cloudCover < 25) {
          clearSkyIndices.push(i);
        } else {
          cloudyIndices.push(i);
        }
      });

      // Prepare precipitation data for bars (scaled to fit 0-10 range)
      const precipitations = data.map(d => d.precipitation || 0);

      new Chart(canvas, {
        type: 'scatter',
        data: {
          labels: labels,
          datasets: [
            {
              label: 'Precipitation (mm)',
              type: 'bar',
              data: precipitations.map((precip, i) => ({ x: i, y: precip })),
              backgroundColor: 'rgba(100, 181, 246, 0.5)',
              borderColor: 'rgba(66, 165, 245, 0.8)',
              borderWidth: 1,
              yAxisID: 'y-temp',
              base: 0,
              barThickness: 2,
              maxBarThickness: 2,
              order: 3
            },
            // Yellow circles behind stars
            {
              label: 'Clear Sky Background',
              data: clearSkyIndices.map(i => ({ x: i, y: temperatures[i] })),
              backgroundColor: '#FFD700',
              borderColor: '#000000',
              borderWidth: 1,
              pointStyle: 'circle',
              pointRadius: 5,
              pointHoverRadius: 5,
              yAxisID: 'y-temp',
              order: 2,
              tooltip: {
                enabled: false
              }
            },
            // Stars on top of yellow circles (clear skies)
            {
              label: 'Temperature (Clear Sky)',
              data: clearSkyIndices.map(i => ({ x: i, y: temperatures[i] })),
              backgroundColor: clearSkyIndices.map(i => pointColors[i]),
              borderColor: clearSkyIndices.map(i => pointColors[i]),
              pointStyle: 'star',
              pointRadius: 5,
              pointHoverRadius: 7,
              yAxisID: 'y-temp',
              order: 1
            },
            // Regular circles (cloudy)
            {
              label: 'Temperature (Cloudy)',
              data: cloudyIndices.map(i => ({ x: i, y: temperatures[i] })),
              backgroundColor: cloudyIndices.map(i => pointColors[i]),
              borderColor: cloudyIndices.map(i => pointColors[i]),
              pointStyle: 'circle',
              pointRadius: 3,
              pointHoverRadius: 5,
              yAxisID: 'y-temp',
              order: 1
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              mode: 'nearest',
              intersect: true,
              callbacks: {
                title: function(tooltipItems) {
                  if (!tooltipItems || !tooltipItems.length) return '';
                  const idx = Math.round(tooltipItems[0].parsed.x);
                  return labels[idx] || '';
                },
                label: function(context) {
                  if (!context || !context.parsed) return '';

                  const dataIndex = Math.round(context.parsed.x);
                  const datasetIndex = context.datasetIndex;

                  if (dataIndex < 0 || dataIndex >= data.length) return '';

                  const precip = data[dataIndex].precipitation || 0;

                  // Precipitation dataset
                  if (datasetIndex === 0) {
                    return `Precipitation: ${precip.toFixed(1)}mm (next 6h)`;
                  }

                  // Skip yellow background layer (dataset 1)
                  if (datasetIndex === 1) {
                    return null;
                  }

                  // Temperature dataset
                  const actualTemp = data[dataIndex].temperature || 0;
                  const displayTemp = context.parsed.y.toFixed(1);
                  let status = '';
                  if (actualTemp < -10) status = ' (Really Good!)';
                  else if (actualTemp < 0) status = ' (Good)';
                  else if (actualTemp < 5) status = ' (Bad)';
                  else status = ' (Really Bad!)';

                  // Show if clamped
                  const clamped = Math.abs(actualTemp - context.parsed.y) > 0.1;
                  const tempDisplay = clamped ? `${actualTemp.toFixed(1)}Â°C (capped at ${displayTemp}Â°C)` : `${displayTemp}Â°C`;

                  // Add cloud cover info
                  const cloudCover = data[dataIndex].cloudCover;
                  const cloudInfo = cloudCover !== null ? ` | Cloud cover: ${cloudCover.toFixed(0)}%${cloudCover < 25 ? ' â­' : ''}` : '';

                  return `${tempDisplay}${status}${cloudInfo}`;
                }
              }
            },
            annotation: {
              annotations: {
                reallyGoodZone: {
                  type: 'box',
                  yMin: -20,
                  yMax: -10,
                  backgroundColor: 'rgba(27, 94, 32, 0.1)',
                  borderWidth: 0
                },
                goodZone: {
                  type: 'box',
                  yMin: -10,
                  yMax: 0,
                  backgroundColor: 'rgba(76, 175, 80, 0.1)',
                  borderWidth: 0
                },
                badZone: {
                  type: 'box',
                  yMin: 0,
                  yMax: 5,
                  backgroundColor: 'rgba(255, 152, 0, 0.1)',
                  borderWidth: 0
                },
                reallyBadZone: {
                  type: 'box',
                  yMin: 5,
                  yMax: 10,
                  backgroundColor: 'rgba(211, 47, 47, 0.1)',
                  borderWidth: 0
                },
                zeroLine: {
                  type: 'line',
                  yMin: 0,
                  yMax: 0,
                  borderColor: '#666',
                  borderWidth: 2,
                  borderDash: [5, 5]
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              type: 'linear',
              ticks: {
                callback: function(value) {
                  if (value >= 0 && value < labels.length) {
                    const label = labels[Math.floor(value)];
                    if (label) {
                      return label.split(' ')[0]; // Show date only
                    }
                  }
                  return '';
                },
                maxTicksLimit: 10,
                autoSkip: true
              }
            },
            'y-temp': {
              display: true,
              position: 'left',
              min: -20,
              max: 10,
              title: {
                display: true,
                text: 'Temperature (Â°C)'
              },
              ticks: {
                stepSize: 5
              }
            },
            'y-precip': {
              display: false
            }
          }
        }
      });

      return wrapper;
    }

    async function init() {
      const loading = document.getElementById('loading');
      const error = document.getElementById('error');
      const chartsContainer = document.getElementById('charts');

      try {
        loading.style.display = 'block';
        error.style.display = 'none';

        const data = await loadData();
        const recentData = filterRecentData(data, DAYS_TO_SHOW);
        const locationGroups = groupByLocation(recentData);

        loading.style.display = 'none';

        if (Object.keys(locationGroups).length === 0) {
          error.textContent = 'No data found. Make sure your sheet is publicly accessible.';
          error.style.display = 'block';
          return;
        }

        // Sort locations alphabetically
        const locations = Object.keys(locationGroups).sort();

        locations.forEach(location => {
          const chart = createChart(location, locationGroups[location]);
          chartsContainer.appendChild(chart);
        });

      } catch (err) {
        loading.style.display = 'none';
        error.textContent = `Error loading data: ${err.message}. Make sure your Google Sheet is shared publicly and the SHEET_ID is correct.`;
        error.style.display = 'block';
      }
    }

    init();
  </script>
</body>
</html>
